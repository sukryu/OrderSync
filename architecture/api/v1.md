# 📡 OrderSync API 설계 문서 (MVP)

> **Last Updated**: 2025-09-27  
> **Version**: 1.0.0 (MVP)  
> **Target**: 3개월 내 출시

-----

## 🎯 **MVP 목표 & 제약사항**

### **핵심 가치 검증**

```
✅ QR 스캔 → 주문 → 결제 → 실시간 알림 (E2E 플로우)
✅ 사장님이 주문을 승인/거절/완료 처리
✅ 토스페이먼츠 결제 연동
✅ 기본적인 보안 (JWT + HTTPS)
```

### **MVP 성능 목표 (현실적)**

```
- 동시 사용자: 100명 (충분)
- API 응답 시간: P99 < 1s (만족스러움)
- 가동률: 99% (초기 단계 적절)
- 일일 주문: 1,000건 처리 가능
```

### **의도적으로 제외한 것들**

```
❌ Circuit Breaker (토스페이 안정적이면 불필요)
❌ GraphQL (REST로 충분)
❌ Redis Cluster (단일 인스턴스로 시작)
❌ 복잡한 Rate Limiting (IP 기반 간단히)
❌ 분산 추적 (로그만으로 충분)
```

-----

## 🏗️ **MVP 아키텍처 (단순화)**

```
┌─────────────────────────────────────┐
│         Nginx (Rate Limit)          │
│         - IP 기반 제한              │
│         - HTTPS 종료                │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│          Go API Server              │
│    - JWT 인증/인가                  │
│    - 비즈니스 로직                  │
│    - 토스페이 연동                  │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│  PostgreSQL + Redis (단일 인스턴스) │
│    - 트랜잭션 데이터 (PG)           │
│    - 세션/캐시 (Redis)              │
└─────────────────────────────────────┘
```

-----

## 📋 **API 엔드포인트 (MVP 전체)**

### **1. 인증 API (4개)**

```
POST   /api/v1/auth/register        # 회원가입
POST   /api/v1/auth/login           # 로그인
POST   /api/v1/auth/refresh         # 토큰 갱신
GET    /api/v1/auth/me              # 내 정보 조회
```

### **2. 고객 주문 API (3개)**

```
GET    /api/v1/restaurants/{id}/menu    # 메뉴 조회 (인증 불필요)
POST   /api/v1/orders                   # 주문 생성
GET    /api/v1/orders/{id}              # 주문 조회
```

### **3. 사장님 관리 API (5개)**

```
GET    /api/v1/restaurants/me/orders               # 주문 목록
POST   /api/v1/restaurants/me/orders/{id}/accept   # 주문 승인
POST   /api/v1/restaurants/me/orders/{id}/reject   # 주문 거절
POST   /api/v1/restaurants/me/orders/{id}/ready    # 준비 완료
POST   /api/v1/restaurants/me/orders/{id}/complete # 주문 완료
```

### **4. 결제 API (2개)**

```
POST   /api/v1/payments/initiate    # 결제 시작 (토스페이 연동)
POST   /api/v1/payments/confirm     # 결제 확인 (토스페이 콜백)
```

### **5. 실시간 알림 (1개)**

```
WebSocket /ws/orders/{order_id}     # 주문 상태 실시간 구독
```

**총 15개 엔드포인트 (MVP에 충분)**

-----

## 🔐 **보안 설계 (단순화)**

### **인증 흐름 (JWT 기반)**

```go
// 1. 로그인 → JWT 발급
POST /api/v1/auth/login
Request:
{
  "email": "user@example.com",
  "password": "securePass123!"
}

Response:
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "expires_in": 3600,
  "user": {
    "id": "uuid",
    "name": "홍길동",
    "role": "CUSTOMER" // or "OWNER"
  }
}

// 2. 이후 요청 시 헤더에 토큰 포함
Authorization: Bearer eyJhbGc...
```

### **간단한 미들웨어 체인**

```go
// 모든 API 요청 흐름
Request → RateLimitMiddleware → AuthMiddleware → Handler

// Rate Limiting (Nginx 레벨)
- IP당 분당 60회 제한 (충분히 관대)

// Auth Middleware (Go 레벨)
func AuthMiddleware(c *gin.Context) {
    token := c.GetHeader("Authorization")
    claims, err := jwt.Validate(token)
    if err != nil {
        c.JSON(401, gin.H{"error": "Unauthorized"})
        return
    }
    c.Set("user_id", claims.UserID)
    c.Set("user_role", claims.Role)
    c.Next()
}
```

### **비밀번호 보안 (bcrypt)**

```go
// 회원가입 시
hashedPassword, _ := bcrypt.GenerateFromPassword(
    []byte(plainPassword), 
    bcrypt.DefaultCost, // Cost 10 (적당한 보안 수준)
)

// 로그인 시
err := bcrypt.CompareHashAndPassword(
    []byte(storedHash), 
    []byte(plainPassword),
)
```

-----

## 📡 **핵심 API 상세 설계**

### **1. 메뉴 조회 (인증 불필요)**

```http
GET /api/v1/restaurants/{restaurant_id}/menu
```

**Response** (200 OK):

```json
{
  "restaurant": {
    "id": "uuid",
    "name": "맛있는 치킨집",
    "table_ordering_enabled": true
  },
  "categories": [
    {
      "id": "uuid",
      "name": "인기 메뉴",
      "items": [
        {
          "id": "uuid",
          "name": "후라이드 치킨",
          "price": 18000,
          "description": "바삭한 후라이드",
          "image_url": "https://cdn.ordersync.com/menu/123.jpg",
          "is_available": true,
          "options": [
            {
              "id": "uuid",
              "name": "순한맛/매운맛",
              "choices": ["순한맛", "매운맛"],
              "required": true
            }
          ]
        }
      ]
    }
  ]
}
```

**캐싱 전략**:

```go
// Redis 캐시 (TTL: 5분)
cacheKey := fmt.Sprintf("menu:%s", restaurantID)
if cached := redis.Get(cacheKey); cached != nil {
    return cached
}

// DB 조회 후 캐싱
menu := db.GetMenu(restaurantID)
redis.SetEx(cacheKey, menu, 5*time.Minute)
return menu
```

-----

### **2. 주문 생성**

```http
POST /api/v1/orders
Authorization: Bearer {token}
```

**Request**:

```json
{
  "restaurant_id": "uuid",
  "table_number": "3",
  "items": [
    {
      "menu_id": "uuid",
      "quantity": 2,
      "options": [
        {
          "option_id": "uuid",
          "choice": "매운맛"
        }
      ]
    }
  ],
  "special_requests": "양파 빼주세요"
}
```

**Response** (201 Created):

```json
{
  "order_id": "uuid",
  "order_number": "A001",
  "status": "PENDING",
  "total_amount": 36000,
  "payment_required": true,
  "payment_url": "https://pay.toss.im/...",
  "websocket_url": "wss://api.ordersync.com/ws/orders/uuid"
}
```

**비즈니스 로직** (단순화):

```go
func CreateOrder(req *CreateOrderRequest) (*Order, error) {
    // 1. 메뉴 가격 검증 (클라이언트 믿지 않기)
    calculatedTotal := 0
    for _, item := range req.Items {
        menu := db.GetMenu(item.MenuID)
        calculatedTotal += menu.Price * item.Quantity
    }
    
    // 2. 주문 생성
    order := &Order{
        ID:           uuid.New(),
        RestaurantID: req.RestaurantID,
        CustomerID:   GetUserID(ctx),
        TotalAmount:  calculatedTotal,
        Status:       "PENDING",
    }
    db.Create(order)
    
    // 3. 토스페이 결제 URL 생성
    paymentURL := toss.CreatePayment(order.ID, calculatedTotal)
    
    // 4. WebSocket 알림 (사장님에게)
    ws.Notify(req.RestaurantID, "NEW_ORDER", order)
    
    return order, nil
}
```

-----

### **3. 주문 승인 (사장님 전용)**

```http
POST /api/v1/restaurants/me/orders/{order_id}/accept
Authorization: Bearer {owner_token}
```

**Request**:

```json
{
  "estimated_time_minutes": 15,
  "message": "곧 준비됩니다!"
}
```

**Response** (200 OK):

```json
{
  "order_id": "uuid",
  "status": "ACCEPTED",
  "estimated_ready_at": "2025-09-27T12:30:00Z"
}
```

**비즈니스 로직**:

```go
func AcceptOrder(orderID string, req *AcceptRequest) error {
    // 1. 권한 확인 (사장님만 가능)
    order := db.GetOrder(orderID)
    if order.RestaurantID != GetOwnerRestaurantID(ctx) {
        return errors.New("Forbidden")
    }
    
    // 2. 상태 변경 (PENDING → ACCEPTED)
    if order.Status != "PENDING" {
        return errors.New("Order already processed")
    }
    order.Status = "ACCEPTED"
    order.EstimatedReadyAt = time.Now().Add(
        time.Duration(req.EstimatedTimeMinutes) * time.Minute,
    )
    db.Update(order)
    
    // 3. 고객에게 실시간 알림
    ws.Notify(order.CustomerID, "ORDER_ACCEPTED", order)
    
    return nil
}
```

-----

### **4. 결제 연동 (토스페이먼츠)**

#### **Step 1: 결제 시작**

```http
POST /api/v1/payments/initiate
```

**Request**:

```json
{
  "order_id": "uuid",
  "amount": 36000,
  "payment_method": "CARD"
}
```

**Response** (200 OK):

```json
{
  "payment_key": "toss_payment_key_123",
  "payment_url": "https://pay.toss.im/abc123",
  "order_id": "uuid",
  "amount": 36000,
  "expires_at": "2025-09-27T12:45:00Z"
}
```

**토스페이 연동 코드**:

```go
func InitiatePayment(req *InitiatePaymentRequest) (*PaymentResponse, error) {
    order := db.GetOrder(req.OrderID)
    
    // 토스페이 API 호출
    tossReq := &toss.CreatePaymentRequest{
        Amount:      req.Amount,
        OrderID:     req.OrderID,
        OrderName:   fmt.Sprintf("주문 #%s", order.OrderNumber),
        SuccessURL:  "https://ordersync.com/payment/success",
        FailURL:     "https://ordersync.com/payment/fail",
    }
    
    tossResp, err := toss.CreatePayment(tossReq)
    if err != nil {
        return nil, err
    }
    
    // Payment 레코드 생성
    payment := &Payment{
        ID:            uuid.New(),
        OrderID:       req.OrderID,
        Amount:        req.Amount,
        Status:        "PENDING",
        TossPaymentKey: tossResp.PaymentKey,
    }
    db.Create(payment)
    
    return &PaymentResponse{
        PaymentKey: tossResp.PaymentKey,
        PaymentURL: tossResp.PaymentURL,
    }, nil
}
```

#### **Step 2: 결제 확인 (토스페이 콜백)**

```http
POST /api/v1/payments/confirm
```

**Request** (토스페이에서 전송):

```json
{
  "paymentKey": "toss_payment_key_123",
  "orderId": "uuid",
  "amount": 36000
}
```

**Response** (200 OK):

```json
{
  "success": true,
  "order_id": "uuid",
  "payment_status": "COMPLETED"
}
```

**비즈니스 로직**:

```go
func ConfirmPayment(req *ConfirmPaymentRequest) error {
    // 1. 토스페이 승인 API 호출
    tossResp, err := toss.ConfirmPayment(req.PaymentKey, req.Amount)
    if err != nil {
        return err
    }
    
    // 2. Payment & Order 상태 업데이트
    payment := db.GetPaymentByTossKey(req.PaymentKey)
    payment.Status = "COMPLETED"
    payment.ApprovedAt = time.Now()
    db.Update(payment)
    
    order := db.GetOrder(payment.OrderID)
    order.PaymentStatus = "PAID"
    db.Update(order)
    
    // 3. 사장님에게 알림
    ws.Notify(order.RestaurantID, "PAYMENT_COMPLETED", order)
    
    return nil
}
```

-----

### **5. 실시간 알림 (WebSocket)**

```
WebSocket: wss://api.ordersync.com/ws/orders/{order_id}
```

**연결 흐름**:

```go
// 클라이언트 연결
ws, _ := websocket.Dial("wss://api.ordersync.com/ws/orders/123")

// 메시지 수신
for {
    var msg OrderStatusMessage
    ws.ReadJSON(&msg)
    
    // UI 업데이트
    updateOrderStatus(msg.Status)
}
```

**서버 메시지 형식**:

```json
{
  "type": "STATUS_CHANGED",
  "order_id": "uuid",
  "status": "ACCEPTED",
  "estimated_ready_at": "2025-09-27T12:30:00Z",
  "message": "주문이 접수되었습니다"
}
```

**WebSocket 구현** (단순화):

```go
func HandleOrderWebSocket(c *gin.Context) {
    orderID := c.Param("order_id")
    
    // WebSocket 업그레이드
    conn, _ := upgrader.Upgrade(c.Writer, c.Request, nil)
    defer conn.Close()
    
    // Redis Pub/Sub 구독
    sub := redis.Subscribe("order:" + orderID)
    defer sub.Close()
    
    // 메시지 전달
    for msg := range sub.Channel() {
        conn.WriteJSON(msg.Payload)
    }
}

// 다른 핸들러에서 알림 발송
func NotifyOrderUpdate(orderID string, data interface{}) {
    redis.Publish("order:"+orderID, data)
}
```

-----

## 📊 **데이터베이스 스키마 (MVP)**

### **PostgreSQL 테이블 (핵심만)**

```sql
-- 사용자
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    role VARCHAR(20) NOT NULL, -- 'CUSTOMER', 'OWNER'
    created_at TIMESTAMP DEFAULT NOW()
);

-- 매장
CREATE TABLE restaurants (
    id UUID PRIMARY KEY,
    owner_id UUID REFERENCES users(id),
    name VARCHAR(200) NOT NULL,
    table_ordering_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 메뉴
CREATE TABLE menus (
    id UUID PRIMARY KEY,
    restaurant_id UUID REFERENCES restaurants(id),
    name VARCHAR(200) NOT NULL,
    price INTEGER NOT NULL,
    is_available BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 주문
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    restaurant_id UUID REFERENCES restaurants(id),
    customer_id UUID REFERENCES users(id),
    order_number VARCHAR(10) NOT NULL,
    table_number VARCHAR(10),
    total_amount INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL, -- 'PENDING', 'ACCEPTED', 'READY', 'COMPLETED'
    payment_status VARCHAR(20) DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_restaurant_status (restaurant_id, status),
    INDEX idx_customer (customer_id)
);

-- 주문 항목
CREATE TABLE order_items (
    id UUID PRIMARY KEY,
    order_id UUID REFERENCES orders(id),
    menu_id UUID REFERENCES menus(id),
    quantity INTEGER NOT NULL,
    unit_price INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 결제
CREATE TABLE payments (
    id UUID PRIMARY KEY,
    order_id UUID REFERENCES orders(id),
    amount INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL, -- 'PENDING', 'COMPLETED', 'FAILED'
    toss_payment_key VARCHAR(255),
    approved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### **Redis 사용 (단순화)**

```go
// 1. JWT 토큰 블랙리스트 (로그아웃)
redis.Set("blacklist:token_123", "1", 24*time.Hour)

// 2. 메뉴 캐시
redis.Set("menu:restaurant_id", menuJSON, 5*time.Minute)

// 3. 실시간 알림 (Pub/Sub)
redis.Publish("order:order_id", messageJSON)
```

-----

## 🔍 **에러 처리 (일관성)**

### **표준 에러 응답 형식**

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "요청 데이터가 올바르지 않습니다",
    "details": {
      "field": "email",
      "reason": "이메일 형식이 아닙니다"
    }
  }
}
```

### **주요 에러 코드**

|HTTP Status|Error Code         |설명                 |
|-----------|-------------------|-------------------|
|400        |VALIDATION_ERROR   |입력 검증 실패           |
|401        |UNAUTHORIZED       |인증 실패              |
|403        |FORBIDDEN          |권한 없음              |
|404        |NOT_FOUND          |리소스 없음             |
|409        |CONFLICT           |상태 충돌 (이미 처리된 주문 등)|
|429        |RATE_LIMIT_EXCEEDED|요청 한도 초과           |
|500        |INTERNAL_ERROR     |서버 오류              |

### **에러 핸들링 코드**

```go
// Custom Error Type
type APIError struct {
    StatusCode int
    Code       string
    Message    string
    Details    interface{}
}

// Error Middleware
func ErrorHandler(c *gin.Context) {
    c.Next()
    
    if len(c.Errors) > 0 {
        err := c.Errors.Last()
        
        switch e := err.Err.(type) {
        case *APIError:
            c.JSON(e.StatusCode, gin.H{
                "error": gin.H{
                    "code":    e.Code,
                    "message": e.Message,
                    "details": e.Details,
                },
            })
        default:
            c.JSON(500, gin.H{
                "error": gin.H{
                    "code":    "INTERNAL_ERROR",
                    "message": "서버 오류가 발생했습니다",
                },
            })
        }
    }
}
```

-----

## 📈 **모니터링 & 로깅 (최소한)**

### **구조화된 로깅**

```go
// 모든 API 요청 로그
log.WithFields(log.Fields{
    "method":    c.Request.Method,
    "path":      c.Request.URL.Path,
    "status":    c.Writer.Status(),
    "duration":  time.Since(start),
    "user_id":   GetUserID(c),
    "ip":        c.ClientIP(),
}).Info("API Request")
```

### **핵심 메트릭 (Prometheus)**

```go
// API 요청 수
apiRequestsTotal.WithLabelValues(
    c.Request.Method,
    c.Request.URL.Path,
    strconv.Itoa(c.Writer.Status()),
).Inc()

// 응답 시간
apiRequestDuration.WithLabelValues(
    c.Request.URL.Path,
).Observe(time.Since(start).Seconds())
```

### **알람 설정 (중요한 것만)**

```yaml
# 알람 규칙 (Alertmanager)
- alert: HighErrorRate
  expr: sum(rate(api_requests_total{status=~"5.."}[5m])) > 10
  annotations:
    summary: "5분간 5xx 에러 10건 초과"
    
- alert: SlowAPI
  expr: api_request_duration{path="/api/v1/orders"} > 2
  annotations:
    summary: "주문 API 응답 2초 초과"
```

-----

## 🚀 **배포 전략 (MVP)**

### **단순 Docker Compose 배포**

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://...
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - TOSS_SECRET_KEY=${TOSS_SECRET_KEY}
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: postgres:15
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: ordersync
      POSTGRES_PASSWORD: ${DB_PASSWORD}
  
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redisdata:/data
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - api

volumes:
  pgdata:
  redisdata:
```

### **환경 변수 (.env)**

```bash
# 데이터베이스
DATABASE_URL=postgresql://user:pass@localhost:5432/ordersync

# Redis
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=your-256-bit-secret-here
JWT_EXPIRES_IN=3600

# 토스페이먼츠
TOSS_SECRET_KEY=test_sk_...
TOSS_CLIENT_KEY=test_ck_...

# 서버
PORT=8080
ENV=production
```

-----

## 📝 **다음 단계 (MVP 구현)**

### **Week 1-2: 기본 인프라**

```bash
✅ Go 프로젝트 초기화
✅ PostgreSQL 스키마 마이그레이션
✅ JWT 인증 미들웨어
✅ 기본 CRUD 구현
```

### **Week 3-4: 핵심 비즈니스 로직**

```bash
✅ 주문 생성/조회 API
✅ 사장님 주문 관리 API
✅ WebSocket 실시간 알림
```

### **Week 5-6: 결제 & 테스트**

```bash
✅ 토스페이먼츠 연동
✅ E2E 테스트
✅ 부하 테스트 (100 동시 사용자)
✅ MVP 배포
```

-----

## 🎯 **MVP 성공 기준**

```
✅ QR 스캔부터 결제 완료까지 5분 이내
✅ 사장님이 주문을 3초 이내 확인
✅ 결제 성공률 95% 이상
✅ API 응답 시간 P99 < 1초
✅ 일일 100건 주문 안정적 처리
```

**MVP 완료 후 → Phase 2 고도화 시작**

-----

<div align="center">

**OrderSync API v1.0.0 (MVP)**

*Simple, Secure, Scalable*

**Last Updated: 2025-09-27**

</div>
